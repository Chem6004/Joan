Computational Exercise 1: A Vary Great, Very Harmonic, WavefunctionÂ¶
We will apply the Variational Method to the Harmonic Oscillator. In particular, we will optimize the trial wavefunction given by
Î¦(ğ‘¥)=exp(âˆ’ğ›¼ğ‘¥2),
 
where  ğ›¼  is an adjustable parameter that will be variationally optimized. In particular, the goal will be to minimize the energy functional given by
ğ¸[Î¦(ğ‘¥)]=âˆ«âˆâˆ’âˆÎ¦âˆ—(ğ‘¥)ğ»Ì‚ Î¦(ğ‘¥)ğ‘‘ğ‘¥âˆ«âˆâˆ’âˆÎ¦âˆ—(ğ‘¥)Î¦(ğ‘¥)ğ‘‘ğ‘¥
 
by modulating the trial wavefunction through the adjustable parameter  ğ›¼ .

The Hamiltonian operator for Harmonic Oscillator is given by
ğ»Ì‚ =âˆ’â„22ğ‘šğ‘‘2ğ‘‘ğ‘¥2+12ğ‘˜ğ‘¥2.
 
We will use a system of natural units where  â„=1 , the mass of the particle  ğ‘š=1 , and the force constant of the potential  ğ‘˜=1 .

Questions
What is the optimal value of  ğ¸[Î¦(ğ‘¥)]  in natural units? How does this value compare to the true ground state energy of the Harmonic Oscillator?
What is the optimal value of  ğ›¼  in natural units? How does  Î¦(ğ‘¥)  with this value of  ğ›¼  compare to the true ground state wavefunction?
What is the kinetic energy expectation value of the optimized trial wavefunction in natural units?
What is the potential energy expectation value of the optimized trial wavefunction in natural units?
(Hopefully) Helpful Hints
You can represent your trial wavefunction numerically on the computer by creating an array of x-values, evaluating the formula for your trial wavefunction at each of those x-values, and then storing each of those function values in another array. The following lines of code will do this using  ğ‘›ğ‘¢ğ‘šğ‘ğ‘¦  arrays and the  ğ‘›ğ‘¢ğ‘šğ‘ğ‘¦.ğ‘’ğ‘¥ğ‘  function.

2
import numpy as np
from matplotlib import pyplot as plt
### create an array of 1000 x-values between x=-20 and x=20 atomic units
x_array = np.linspace(-20,20,1000)
### pick a trial value of alpha... might as well be 1 atomic unit!
alpha = 1.0
### evaluate your trial wavefunction at each of the x-values stored in the array called 'x_array'
Phi = np.exp(-alpha * x_array**2)
Vx= 1/2. * x_array **2
plt.plot (x_array, Phi, 'purple', label= 'Trial run')
plt.plot(x_array, Vx, 'green', label= 'potential')
plt.xlim (-5,5)
plt.ylim(0,2)
plt.legend()
â€‹
plt.show()

To evaluate the kinetic energy of a trial wavefunction, we will need to take the second derivative of the trial wavefunction. One way to take derivatives on a computer is to use the method of finite differences. In particular, the forward finite difference approximation to the first derivative of your trial wavefunction Î¦(ğ‘¥) at the point ğ‘¥0 can be written symbolically as
ğ‘‘Î¦(ğ‘¥0)ğ‘‘ğ‘¥=Î¦(ğ‘¥0+ğ‘‘ğ‘¥)âˆ’Î¦(ğ‘¥0)ğ‘‘ğ‘¥
where in our code, ğ‘‘ğ‘¥ will be determined by the range of x-values and the number of x-values used in defining ğ‘¥ğ‘ğ‘Ÿğ‘Ÿğ‘ğ‘¦.

Create a function called ğ‘‘ğ‘“ğ‘‘ğ‘¥ that takes an array of x-values and an array of function values evaluated at each x-value and returns the first derivative of the function values with respect to x. Then, show that calling this function in sequence can be used to compute the second derivative of an array of function values.

A skeleton of the function looks like this:

def dfdx(fx, x):
    ### loop through values of fx and x and use forward finite-differences 
    ### to compute the d/dx of fx at each point and store in an array called 'fxp'
    ### make sure to poperly handle
    ### the last point where f(x_0 + dx) is not stored
    fxp = np.zeros_like(fx)
    
    for i in range(0,len(x)-1):
        rise= fx[i+1] -fx[i]
        run= x[i+1] - x[i]
        slope= rise/ run
        fxp[i] = slope
    
    ### create a numpy array called fxp that has the same length
    ### and data type as the array of function values you are differentiating
    
      
    ''' your forward finite difference code goes here! 
    
    
    '''
    
    ### once you have computed all fxp values, return the array!
    return fxp
And the calling sequence for ğ‘‘ğ‘“ğ‘‘ğ‘¥ to compute the second derivative of a trial wavefunction we defined previously will look like this:

### Call dfdx on Phi to get the first derivative of Phi
Phi_p = dfdx(Phi, x_array)
â€‹
Phi_wa = -2 * alpha * x_array * Phi
â€‹
plt.plot(x_array, Phi_p, 'red', label= 'dfdx result')
plt.plot (x_array, Phi_wa,'b--' , label= 'Wolfram alpha result')
plt.legend()
â€‹
plt.show()
â€‹
â€‹
### Call dfdx on Phi_p to get the second derivative of Phi
Phi_pp = dfdx(Phi_p, x_array)
â€‹

â€‹
